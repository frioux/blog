---
title: DBI Caller Info
date: 2016-06-08T23:26:52
tags: [ziprecruiter, dbi, perl]
guid: "https://blog.afoolishmanifesto.com/posts/dbi-caller-info"
---
At [ZipRecruiter](https://web.archive.org/web/20190330183125/https://www.ziprecruiter.com/hiring/technology) we have a system for appending
metadata to queries generated by
[DBIx::Class](https://metacpan.org/pod/DBIx::Class).  About a month ago [I
posted about bolting timeouts onto
MySQL](https://blog.afoolishmanifesto.com/posts/put-mysql-in-timeout/) and in
the referenced code I mentioned parsing said metadata.  We are depending on that
metadata more and more to set accurate timeouts on certain page types.

<!--more-->

# Adding Metadata to DBI Queries

Because of our increased dependence on query metadata, I decided today that I'd
look into setting the metadata at the DBI layer instead of the DBIx::Class
layer.  This not only makes debugging certain queries easier, but more
importantly allows us to give extra grace to queries coming from certain
contexts.


First we define the boilerplate packages:

```
package ZR::DBI;

use 5.14.0;
use warnings;

use base 'DBI';

use ZR::DBI::db;
use ZR::DBI::st;

1;
```

```
package ZR::DBI::st;

use 5.14.0;
use warnings;

use base 'DBI::st';

1;

```

Next we intercept the prepare method.  In this example we only grab the
innermost call frame.  At work we not only walk backwards based on a regex on
the filename; we also have a hash that adds extra data, like what controller and
action are being accessed when in a web context.

```
package ZR::DBI::db;

use 5.14.0;
use warnings;

use base 'DBI::db';

use JSON::XS ();

sub prepare {
  my $self = shift;
  my $stmt = shift;

  my ($class, $file, $line, $sub) = caller();

  $stmt .= " -- ZR_META: " . encode_json({
    class => $class,
    file  => $file,
    line  => $line,
    sub   => $sub,
  }) . "\n";

  $self->SUPER::prepare($stmt, @_);
}

1;

```

Finally use the subclass:

```
my $dbh = DBI->connect($dsn, $user, $password, {
    RaiseError         => 1,
    AutoCommit         => 1,

    RootClass          => 'ZR::DBI',
});
```

---

The drawback of the above is that it could (and maybe is?) destroying the
caching of prepared statements.  In our system that doesn't seem to be very
problematic, but I suspect it depends on RDBMS and workload.  Profile your
system before blindly following these instructions.

Wow that's all there is to it!  I expected this to be a lot of work, but it
turns out Tim Bunce had my back and made this pretty easy.  It's pretty great
when something as central as database access has been standardized!
